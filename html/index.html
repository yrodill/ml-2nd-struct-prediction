<!DOCTYPE html>
<html>

<head>
    <meta charset="utf8">
    <title>StruBiGL</title>
</head>

<body>
    <script type="module">

        'use strict';

        // function getListOfFeaturesOfInterest(obj1, obj2) {
        //     let result = [];
        //     result = [];

        //     for (let i = 0; i < obj1.length; i++) {
        //         for (let key in obj1[i]) {
        //             if (obj1[i][key] === 0) {
        //                 result.push(key);
        //             }
        //         }
        //     }
        //     for (let i = 0; i < obj2.length; i++) {
        //         for (let key in obj2[i]) {
        //             if (obj2[i][key] === 0) {
        //                 result.push(key);
        //             }
        //         }
        //     }

        //     let dic = {};

        //     for (let i = 0; i < result.length; i++) {
        //         dic[result[i]] = 0;
        //     }
        //     for (let i = 0; i < result.length; i++) {
        //         dic[result[i]] += 1;
        //     }
        //     for (let key in dic) {
        //         if (dic[key] < 200) {
        //             delete dic[key];
        //         }
        //     }
        //     // console.log(Object.keys(dic).length);
        //     return dic;
        // }

        // function reduceDimensions(obj, listOfFeaturesOfInterest) {

        //     for (let i = 0; i < obj.length; i++) {

        //         for (let key in obj[i]) {
        //             if (key in listOfFeaturesOfInterest) {
        //                 delete obj[i][key];
        //             }
        //         }
        //     }
        //     return obj;
        // }

        function createDipeptideObj() {
            let dipeptidesInit = {};
            let AAs = ["A", "D", "R", "N", "C", "E", "Q", "G", "H", "I", "L", "K", "M", "F", "P", "S", "T", "W", "Y", "V"];
            AAs.forEach(function (element) {
                for (let j = 0; j < AAs.length; j++) {
                    let word = element + AAs[j];
                    dipeptidesInit[word] = 0;
                }
            });
            return dipeptidesInit;

        }


        function calcDipeptideFeatures(result, arrayOfHydrophibicity) {
            let features = [];
            for (let i = 0; i < result.length; i++) {
                let dipeptides = createDipeptideObj();
                for (let j = 0; j < result[i].length - 1; j++) {
                    let word = result[i][j] + result[i][j + 1];
                    dipeptides[word] += 1;
                }
                let len = result[i].length - 1;
                for (let key in dipeptides) {
                    dipeptides[key] = dipeptides[key] / len;
                }
                dipeptides["hydrophibicity"] = arrayOfHydrophibicity[i];
                features[i] = dipeptides;
            }
            // console.log(features);
            return features;



        }


        function testOnData(sequence, threshold) {

            /*run on data*/
            var result = [];
            sequence.forEach(function (arrayItem) {
                var output = net.run(arrayItem);
                // console.log(output);
                result.push(output);
            });

            /*Calc % of true positives using a threshold
            threshold must be between 0 and 1*/
            const filterAlpha = result.filter(property => property.alpha >= threshold);
            const filterBeta = result.filter(property => property.beta >= threshold);

            var trueAlpha = filterAlpha.length / result.length;
            var roundedTrueAlpha = Math.round(trueAlpha * 100) / 100;
            var trueBeta = filterBeta.length / result.length;
            var roundedTrueBeta = Math.round(trueBeta * 100) / 100;

            console.log(`Test pour alpha`);
            console.log(`True positives : ${roundedTrueAlpha * 100}%`);
            console.log(`Test pour beta`);
            console.log(`True positives : ${roundedTrueBeta * 100}%`);

        }

        /*Find features and store them*/

        function process(data) {
            let result = [];

            /* Read data from fasta format*/
            let tab = data.split("\n");

            for (let i = 0; i < tab.length; i++) {
                let sequence = "";
                if (tab[i] != "" && tab[i][0] != ">") { //remove "\n" and concatenate untill reaches a new ">" 
                    while (tab[i] != "" && tab[i][0] != ">") {
                        sequence += tab[i];
                        i++;
                    }
                    result.push(sequence);
                }
            }

            // console.log(test);

            // console.log(result);

            /*Hydrophobicity Kyte-Doolittle scale
            Isoleucine 	I 	4.5
            Valine 	V 	4.2
            Leucine 	L 	3.8
            Phenylalanine 	F 	2.8
            Cysteine 	C 	2.5
            Methionine 	M 	1.9
            Alanine 	A 	1.8
            Glycine 	G 	-0.4
            Threonine 	T 	-0.7
            Serine 	S 	-0.8
            Tryptophan 	W 	-0.9
            Tyrosine 	Y 	-1.3
            Proline 	P 	-1.6
            Histidine 	H 	-3.2
            Glutamic acid 	E 	-3.5
            Glutamine 	Q 	-3.5
            Aspartic acid 	D 	-3.5
            Asparagine 	N 	-3.5
            Lysine 	K 	-3.9
            Arginine 	R 	-4.5
            */

            let KDHydrophobicity = { "I": 4.5, "V": 4.2, "L": 3.8, "F": 2.8, "C": 2.5, "M": 1.9, "A": 1.8, "G": -0.4, "T": -0.7, "S": -0.8, "W": -0.9, "Y": -1.3, "P": -1.6, "H": -3.2, "E": -3.5, "Q": -3.5, "D": -3.5, "N": -3.5, "K": -3.9, "R": -4.5 };
            let H = [];
            let averageH = 0;

            //On calcule l'hydrophibicité de l'élément central en prenant une chaîne de 7 AA ref: http://perso.ibcp.fr/gilbert.deleage/Cours/BIOINFO_hydrophobie.html
            for (let i = 0; i < result.length; i++) {
                let hydropathie = [];
                for (let j = 0; j < result[i].length; j++) {
                    if (j > 2 && j < result[i].length - 3) {
                        averageH = (KDHydrophobicity[result[i][j - 3]] + KDHydrophobicity[result[i][j - 2]] + KDHydrophobicity[result[i][j - 1]]
                            + KDHydrophobicity[result[i][j]] + KDHydrophobicity[result[i][j + 1]] + KDHydrophobicity[result[i][j + 2]] + KDHydrophobicity[result[i][j + 3]]) / 7;
                        hydropathie.push(averageH);
                    }
                    else {
                        averageH = KDHydrophobicity[result[i][j]];
                        hydropathie.push(averageH);
                    }
                }
                let averageHydropathie = 0;
                for (let k = 0; k < hydropathie.length; k++) {
                    averageHydropathie += hydropathie[k];
                }
                averageHydropathie /= hydropathie.length;
                H.push(averageHydropathie)

            }
            // console.log("Tableau d'hydrophobicité : ", H);

            /*Test for 400 features
            Processing time really high and 100% alpha always => overfitting ?*/
            // let features = calcDipeptideFeatures(result, H);
            // console.log("Tableau de features : ", features);
            // return features;

            /*Calc features for the sequences in the fasta file
            Infos : AA impliqués dans la formation des hélices alpha : MALEK
                    AA impliqués dans la formation des feuillets beta: FYWTVIL et P aux extrémités.
            */
            let features = [];
            for (let i = 0; i < result.length; i++) {
                let matrix = { "A": 0, "D": 0, "R": 0, "N": 0, "C": 0, "E": 0, "Q": 0, "G": 0, "H": 0, "I": 0, "L": 0, "K": 0, "M": 0, "F": 0, "P": 0, "S": 0, "T": 0, "W": 0, "Y": 0, "V": 0 };
                for (let j = 0; j < result[i].length; j++) {
                    matrix[result[i][j]] += 1;
                }
                let len = result[i].length;
                for (let key in matrix) {
                    matrix[key] = matrix[key] / len;
                }
                matrix["hydrophibicity"] = H[i];
                features[i] = matrix;
            }
            // console.log(features);
            return features;

        }
        /*MAIN*/
        var betaFeatures = process(dataset);
        var alphaTest = process(alpha);
        var alphaHTest = process(alphaH);
        var alphasGlob = process(alphas);
        var betasGlob = process(betas);
        var test1 = process(Test1);
        var test2 = process(Test2);
        var test3 = process(Test3);
        var test4 = process(Test4);
        var test5 = process(Test5);

        // let listOfFeatures = getListOfFeaturesOfInterest(betaFeatures, alphaTest);
        // betaFeatures = reduceDimensions(betaFeatures, listOfFeatures);
        // alphaTest = reduceDimensions(alphaTest, listOfFeatures);
        // alphaHTest = reduceDimensions(alphaHTest, listOfFeatures);
        // alphasGlob = reduceDimensions(alphasGlob, listOfFeatures);
        // betasGlob = reduceDimensions(betasGlob, listOfFeatures);
        // test1 = reduceDimensions(test1, listOfFeatures);
        // test2 = reduceDimensions(test2, listOfFeatures);
        // test3 = reduceDimensions(test3, listOfFeatures);
        // test4 = reduceDimensions(test4, listOfFeatures);
        // test5 = reduceDimensions(test5, listOfFeatures);

        // console.log(betaFeatures);

        // var f = [];
        // var keys = [];

        // for (let i = 0; i < betaFeatures.length; i++) {
        //     var arr = [];

        //     for(var key in betaFeatures[i]){
        //         arr.push(betaFeatures[i][key]);
        //         if(i==0){
        //         keys.push(key);
        //         }
        //     }
        //     f.push(arr);
        // }
        // console.log(keys);
        // console.log(f);

        // var vectors = PCA.getEigenVectors(f);
        // console.log("PCA result :", vectors);

        // var adData = PCA.computeAdjustedData(f, vectors[0]);
        // console.log(adData);

        // var feat = [];
        // for(let i=0;i<keys.length;i++){
        //     var dic = {};
        //     dic[keys[i]] = vectors[i].eigenvalue;
        //     feat.push(dic);
        // }
        // console.log("Final features : ",feat);


        // /*Training and inferences*/
        // /* Features format : [{input:{features} , output:{beta:1,alpha:0}}]*/
        var net = new brain.NeuralNetwork();
        var config = [];

        /*Train classifier on alphaG & beta*/
        test2.forEach(function (arrayItem) {
            config.push({ input: arrayItem, output: { beta: 1, alpha: 0 } });
        });
        // betasGlob.forEach(function (arrayItem) {
        //     config.push({ input: arrayItem, output: { beta: 1, alpha: 0 } });
        // });
        test3.forEach(function (arrayItem) {
            config.push({ input: arrayItem, output: { beta: 1, alpha: 0 } });
        });


        alphaTest.forEach(function (arrayItem) {
            config.push({ input: arrayItem, output: { beta: 0, alpha: 1 } });
        });
        // alphasGlob.forEach(function (arrayItem) {
        //     config.push({ input: arrayItem, output: { beta: 0, alpha: 1 } });
        // });

        alphaHTest.forEach(function (arrayItem) {
            config.push({ input: arrayItem, output: { beta: 0, alpha: 1 } });
        });

        console.log("Training has begun ! Wait...");
        net.train(config);
        console.log("Training, done. Yay!");

        // /*Test classifier*/
        let threshold=0.8;
        // testOnData(test1,threshold);
        console.log("-------------------------------------------------------------------");
        testOnData(betaFeatures, threshold);
        console.log("-------------------------------------------------------------------");
        // testOnData(test3, threshold);
        // console.log("-------------------------------------------------------------------");
        testOnData(test4, threshold);
        console.log("-------------------------------------------------------------------");
        testOnData(test5, threshold);
        console.log("-------------------------------------------------------------------");
        // testOnData(betasGlob, threshold);
        // console.log("-------------------------------------------------------------------");
        // testOnData(alphasGlob, threshold);


    </script>
</body>

<script type="text/javascript" , src="../data/mainlybeta.js"></script>
<script type="text/javascript" , src="../data/mainlyalphaG.js"></script>
<script type="text/javascript" , src="../data/alphaH.js"></script>
<script type="text/javascript" , src="../data/mainlybetaAnthropleurine.js"></script>
<script type="text/javascript" , src="../data/mainlyalphaglob.js"></script>
<script type="text/javascript" , src="../data/datatest/Test1.js"></script>
<script type="text/javascript" , src="../data/datatest/Test2.js"></script>
<script type="text/javascript" , src="../data/datatest/Test3.js"></script>
<script type="text/javascript" , src="../data/datatest/Test4.js"></script>
<script type="text/javascript" , src="../data/datatest/Test5.js"></script>
<script src="https://cdn.jsdelivr.net/npm/@tensorflow/tfjs@0.13.3/dist/tf.min.js"> </script>
<script type="text/javascript" src="https://cdnjs.cloudflare.com/ajax/libs/brain/0.6.3/brain.js"></script>
<script type="text/javascript" src="https://cdn.jsdelivr.net/npm/pca-js@1.0.0/pca.min.js"></script>


</html>